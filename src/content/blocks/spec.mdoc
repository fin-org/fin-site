## Core Specification

- File extension is `.fin`
- MIME type is `application/fin`

### Decoding Modes

Consider decoders handling input that is produced

1. by a fin encoder (e.g. interchange between programs).
2. directly via a text editor (e.g. a human).

The expected input in these two situations differs significantly along with how a decoder should
behave. Fin decoders support both modes and this specification is designed accordingly.

#### Strict Mode

- Expectation is input was produced by a fin encoder and _should_ be valid in most cases.
- Decoders should fail immediately when _any_ invalid input is detected.
- Is the **default** mode.
- Does not check for correct formatting.

#### Editor Mode

- Expectation is input was constructed directly in a text editor and is often invalid.
- In cases where the input is invalid, but it can be determined precisely what was intended then
  decoders should correct it, emit a warning and continue decoding.
- This specification will explicitly point out when input is **correctable**.
- This mode may also emit warnings, and correct, valid input.
- Does not check for correct formatting.

### Text representation

- The fin format is defined in terms of Unicode text (code points).
- Each code point is distinct (e.g. case-sensitive).
- Fin encoders and decoders do not perform Unicode Normalization.
- All fin payloads must be encoded as UTF-8. Invalid UTF-8 is invalid Fin.
- Decoders will ignore a UTF-8 encoded byte order mark `U+FEFF` at the start of input.
- Encoders must not emit a byte order mark at the start of output.

Unicode provides a huge range of code points to choose from, many of which serve no practical
purpose in a data interchange format. In fact when humans are involved, some code points could be
confusing and even [dangerous](https://trojansource.codes/).

The majority of fin notation uses a very small [set](#core-set-cs) of _safe_ code points, so safety
concerns are somewhat localised. However, Unicode does allow conveying text other than Basic Latin
in its naturally intended form which is desirable for strings and comments.

It is tempting to make specific Unicode ranges strictly invalid in this specification. However, that
approach has significant downsides. Instead, fin advocates for warnings + escape sequences in
[editor mode](#editor-mode) and encoding APIs that default to escaping suspect code points.

#### Core Set (CS)

The core set of code points is used for the majority of fin notation, everything except the contents
of [strings](#strings) and [comments](#comments). It contains

- 3 control codes
  - horizontal tab **HT**
  - line feed **LF**
  - carriage return **CR** (correctable)
- 10 decimal digits **0-9**
- 26 lowercase letters **a-z**
- 26 uppercase letters **A-Z** (correctable)
- 14 other code points
  - space **SP**
  - **" # ( ) , - . : [ ] \_ |**
  - **+** (correctable)

```
control (3) = U+0009, U+000A, U+000D
digits (10) = U+0030 - U+0039 (incl.)
lower  (26) = U+0061 - U+007A (incl.)
upper  (26) = U+0041 - U+005A (incl.)
other  (14) = U+0021, U+0022, U+0023, U+0028,
  U+0029, U+002B, U+002C, U+002D, U+002E,
  U+003A, U+005B, U+005D, U+005F, U+007C
```

Some notes on the core set.

- Is a subset of the Basic Latin Unicode Block (ASCII).
- All code points are a single byte in UTF-8 (simplifies decoding).
- Is small, only **79** total code points.
- In strict mode it shrinks to **51** total code points. Less than half of ASCII.
- Restricting input aids general purpose compression algorithms.

### Symbols

{% code_example id="symbols" /%}

### Numbers

{% code_example id="numbers" /%}

### Strings

- Fin string literals convey Unicode text and are _guaranteed_ to represent a valid sequence of
  UTF-8 bytes.
  - [Extension](#extension) should be used for alternate interpretations and semantics (e.g. binary
    to text encoding).
- Two syntax forms are provided [escaped](#escaped-strings), and [raw](#raw-strings).

#### Escaped Strings

- Escaped strings are delimited by double quotation marks `"`.
- They have **inline** notation (start and end on the same line).
- Can represent **any** Unicode code point. Including those outside of [ES](#extended-set-es).
- To achieve this, escape sequence interpretation is used.
  - `\` initiates an escape sequence.
    - An error occurs if the next code point results in an unknown escape sequence.
    - An escape sequence (`\\`) must now be used to represent a single backslash.
  - `"` will terminate the string.
    - Can be escaped using `\"` to appear within the string.
  - The 3 control codes within [ES](#extended-set-es) are **correctable** by replacing them with
    escape sequences. No line ending or tab normalization occurs.
    - `\t` - Horizontal tab **HT**
    - `\n` - Line feed **LF**
    - `\r` - Carriage return **CR**
  - All code points outside [ES](#extended-set-es) must use the Unicode escape sequence to be
    included in the string.
    - `\u{hex}` where `hex` is the hexadecimal number for any
      [Unicode Scalar Value](https://unicode.org/glossary/#unicode_scalar_value)
      - Which is any code point except high-surrogates and low-surrogates.
    - If required the hex code will be **corrected** to lowercase and leading zeros trimmed (except
      for 0).

{% code_example id="escaped_strings" /%}

#### Raw Strings

- A notation for strings without escaping or any interpretation.
- Line feeds cannot be escaped so by definition raw strings can _expand_ to multiple lines. Raw
  strings have **expanded** notation.
- Raw strings are initiated by a vertical bar `|`
- The are terminated by the following sequence
  - A line feed
  - Any number of optional spaces or horizontal tabs
  - A code point other than `|`
- The raw string contains all code points that follow `|`, up to and including **LF**, for all lines
  that make up the string.
- Carriage return **CR** is strictly invalid in raw strings.
  - When immediately followed by **LF** the user unambiguously intends to go to the next line. The
    line ending is **corrected** by removing the **CR**.
  - All other carriage returns are an error.
- Raw strings are unable to represent code points outside the [extended set](#extended-set-es). So
  they're more limited than [escaped strings](#escaped-strings) in what they can represent.
  - Raw strings can always be converted to escaped strings, but the reverse does not hold.
- Machines have no issue dealing escaped strings however for humans it can be challenging to deal
  with escaped strings in certain situations
  - text that frequently uses `\` or has its own escaping scheme (regex)
  - text with many lines perhaps with indentation (verbatim code snippets)
- Raw strings are a notation for _humans_.

{% code_example id="raw_strings" /%}

### Comments

{% code_example id="comments" /%}

### Arrays

{% code_example id="arrays" /%}

### Maps

{% code_example id="maps" /%}

### Top Level Value

### Extensions
